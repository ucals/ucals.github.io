<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Conditional Variational Auto-encoder | cs</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Conditional Variational Auto-encoder" />
<meta name="author" content="carlos souza" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This tutorial implements Learning Structured Output Representation using Deep Conditional Generative Models paper, which introduced Conditional Variational Auto-encoders in 2015, using Pyro PPL and PyTorch." />
<meta property="og:description" content="This tutorial implements Learning Structured Output Representation using Deep Conditional Generative Models paper, which introduced Conditional Variational Auto-encoders in 2015, using Pyro PPL and PyTorch." />
<link rel="canonical" href="http://localhost:4000/paper/2020/09/18/conditional-variational-auto-encoder.html" />
<meta property="og:url" content="http://localhost:4000/paper/2020/09/18/conditional-variational-auto-encoder.html" />
<meta property="og:site_name" content="cs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-18T11:57:41-03:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"carlos souza"},"url":"http://localhost:4000/paper/2020/09/18/conditional-variational-auto-encoder.html","headline":"Conditional Variational Auto-encoder","dateModified":"2020-09-18T11:57:41-03:00","datePublished":"2020-09-18T11:57:41-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/paper/2020/09/18/conditional-variational-auto-encoder.html"},"description":"This tutorial implements Learning Structured Output Representation using Deep Conditional Generative Models paper, which introduced Conditional Variational Auto-encoders in 2015, using Pyro PPL and PyTorch.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="cs" />
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">cs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Conditional Variational Auto-encoder</h1>
    <p class="post-meta"><time class="dt-published" datetime="2020-09-18T11:57:41-03:00" itemprop="datePublished">
        Sep 18, 2020
      </time>• <span class="reading-time" title="Estimated read time">
    
    9 min read
</span>
    </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This tutorial implements <a href="http://papers.nips.cc/paper/5775-learning-structured-output-representation-using-deep-conditional-generati">Learning Structured Output Representation using Deep Conditional Generative Models</a> paper, which introduced Conditional Variational Auto-encoders in 2015, using <a href="http://pyro.ai/">Pyro PPL</a> and <a href="https://pytorch.org/">PyTorch</a>.
<!--more--></p>

<h2 id="introduction">Introduction</h2>
<blockquote>
  <p>“Never disdain to make a verification when opportunity offers.” Henri Poincaré.</p>
</blockquote>

<p>Supervised deep learning has been successfully applied for many recognition problems in machine learning and computer 
vision. Although it can approximate a complex many-to-one function very well when large number of training data is 
provided, the lack of probabilistic inference of the current supervised deep learning methods makes it difficult to 
model a complex structured output representations. In this work, Kihyuk Sohn, Honglak Lee and Xinchen Yan develop a 
scalable deep conditional generative model for structured output variables using Gaussian latent variables. The model 
is trained efficiently in the framework of stochastic gradient variational Bayes, and allows a fast prediction using 
stochastic feed-forward inference. They called the model Conditional Variational Auto-encoder (CVAE) <a class="citation" href="#NIPS2015_5775">(Sohn et al., 2015)</a>.</p>

<p>The CVAE is a conditional directed graphical model whose input observations modulate the prior on Gaussian latent 
variables that generate the outputs. It is trained to maximize the conditional marginal log-likelihood. The authors 
formulate the variational learning objective of the CVAE in the framework of stochastic gradient variational Bayes 
(SGVB). In experiments, they demonstrate the effectiveness of the CVAE in comparison to the deterministic neural 
network counterparts in generating diverse but realistic output predictions using stochastic inference. Here, we will 
implement their proof of concept: an artificial experimental setting for structured output prediction using MNIST 
database.</p>

<h2 id="the-problem">The problem</h2>
<p>Let’s divide each digit image into four quadrants, and take one, two, or three quadrant(s) as an input and the 
remaining quadrants as an output to be predicted. The image below shows the case where one quadrant is the input:</p>

<p><img src="https://i.ibb.co/x17xFwy/image1.png" alt="image1" width="400" /></p>

<p>Our objective is to <strong>learn a model that can perform probabilistic inference and make diverse predictions from a 
single input</strong>. This is because we are not simply modeling a many-to-one function as in classification tasks, but we 
may need to model a mapping from single input to many possible outputs. One of the limitations of deterministic neural 
networks is that they generate only a single prediction. In the example above, the input shows a small part of a digit 
that might be a three or a five.</p>

<h2 id="preparing-the-data">Preparing the data</h2>
<p>We use the MNIST dataset; the first step is to prepare it. Depending on how many quadrants we will use as inputs, we 
will build the datasets and dataloaders, removing the unused pixels with -1:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">CVAEMNIST</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">MNIST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="n">download</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">original</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">image</span><span class="p">,</span> <span class="n">digit</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">original</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="p">{</span><span class="s">'original'</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="s">'digit'</span><span class="p">:</span> <span class="n">digit</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">transform</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sample</span>


<span class="k">class</span> <span class="nc">ToTensor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
        <span class="n">sample</span><span class="p">[</span><span class="s">'original'</span><span class="p">]</span> <span class="o">=</span> <span class="n">functional</span><span class="p">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">'original'</span><span class="p">])</span>
        <span class="n">sample</span><span class="p">[</span><span class="s">'digit'</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">'digit'</span><span class="p">]),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>


<span class="k">class</span> <span class="nc">MaskImages</span><span class="p">:</span>
    <span class="s">"""This torchvision image transformation prepares the MNIST digits to be
    used in the tutorial. Depending on the number of quadrants to be used as
    inputs (1, 2, or 3), the transformation masks the remaining (3, 2, 1)
    quadrant(s) setting their pixels with -1. Additionally, the transformation
    adds the target output in the sample dict as the complementary of the input
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_quadrant_inputs</span><span class="p">,</span> <span class="n">mask_with</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_quadrant_inputs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_quadrant_inputs</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'Number of quadrants as inputs must be 1, 2 or 3'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num_quadrant_inputs</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mask_with</span> <span class="o">=</span> <span class="n">mask_with</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="s">'original'</span><span class="p">].</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">.</span><span class="n">detach</span><span class="p">().</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">.</span><span class="n">shape</span>

        <span class="c1"># removes the bottom left quadrant from the target output
</span>        <span class="n">out</span><span class="p">[</span><span class="n">h</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:</span><span class="n">w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mask_with</span>
        <span class="c1"># if num of quadrants to be used as input is 2,
</span>        <span class="c1"># also removes the top left quadrant from the target output
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mask_with</span>
        <span class="c1"># if num of quadrants to be used as input is 3,
</span>        <span class="c1"># also removes the top right quadrant from the target output
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">num</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:</span><span class="n">h</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mask_with</span>

        <span class="c1"># now, sets the input as complementary
</span>        <span class="n">inp</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">inp</span><span class="p">[</span><span class="n">out</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mask_with</span>

        <span class="n">sample</span><span class="p">[</span><span class="s">'input'</span><span class="p">]</span> <span class="o">=</span> <span class="n">inp</span>
        <span class="n">sample</span><span class="p">[</span><span class="s">'output'</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">sample</span>


<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">num_quadrant_inputs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">([</span>
        <span class="n">ToTensor</span><span class="p">(),</span>
        <span class="n">MaskImages</span><span class="p">(</span><span class="n">num_quadrant_inputs</span><span class="o">=</span><span class="n">num_quadrant_inputs</span><span class="p">)</span>
    <span class="p">])</span>
    <span class="n">datasets</span><span class="p">,</span> <span class="n">dataloaders</span><span class="p">,</span> <span class="n">dataset_sizes</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'train'</span><span class="p">,</span> <span class="s">'val'</span><span class="p">]:</span>
        <span class="n">datasets</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">CVAEMNIST</span><span class="p">(</span>
            <span class="s">'../data'</span><span class="p">,</span>
            <span class="n">download</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="p">,</span>
            <span class="n">train</span><span class="o">=</span><span class="n">mode</span> <span class="o">==</span> <span class="s">'train'</span>
        <span class="p">)</span>
        <span class="n">dataloaders</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
            <span class="n">datasets</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="n">mode</span> <span class="o">==</span> <span class="s">'train'</span><span class="p">,</span>
            <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">dataset_sizes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">dataloaders</span><span class="p">,</span> <span class="n">dataset_sizes</span></code></pre></figure>

<h2 id="baseline-deterministic-neural-network">Baseline: Deterministic Neural Network</h2>
<p>Before we dive into the CVAE implementation, let’s code the baseline model. It is a straightforward implementation:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">BaselineNet</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">784</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_2</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
        <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">hidden</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">hidden</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">y</span></code></pre></figure>

<p>In the paper, the authors compare the baseline NN with the proposed CVAE by comparing the negative (Conditional) Log 
Likelihood (CLL), averaged by image in the validation set. Thanks to PyTorch, computing the CLL is equivalent to 
computing the Binary Cross Entropy Loss using as input a signal passed through a Sigmoid layer. The code below does a 
small adjustment to leverage this: it only computes the loss in the pixels not masked with -1:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">MaskedBCELoss</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masked_with</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">masked_with</span> <span class="o">=</span> <span class="n">masked_with</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="nb">input</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">binary_cross_entropy</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
        <span class="n">loss</span><span class="p">[</span><span class="n">target</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">masked_with</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">loss</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span></code></pre></figure>

<p>The training is very straightforward. We use 500 neurons in each hidden layer, Adam optimizer with <code class="language-plaintext highlighter-rouge">1e-3</code> learning 
rate, and early stopping. Please check the <a href="https://github.com/pyro-ppl/pyro/blob/dev/examples/cvae">Github repo</a> for 
the full implementation.</p>

<h2 id="deep-conditional-generative-models-for-structured-output-prediction">Deep Conditional Generative Models for Structured Output Prediction</h2>
<p>As illustrated in the image below, there are three types of variables in a deep conditional generative model (CGM): 
input variables $\bf x$, output variables $\bf y$, and latent variables $\bf z$. The conditional generative process of 
the model is given in (b) as follows: for given observation $\bf x$, $\bf z$ is drawn from the prior distribution 
$p_{\theta}({\bf z} | {\bf x})$, and the output $\bf y$ is generated from the distribution 
$p_{\theta}({\bf y} | {\bf x, z})$. Compared to the baseline NN (a), the latent variables $\bf z$ allow for modeling 
multiple modes in conditional distribution of output variables $\bf y$ given input $\bf x$, making the proposed CGM 
suitable for modeling one-to-many mapping.</p>

<p><img src="https://i.ibb.co/0mVvkSF/image2.png" alt="image1" width="800" /></p>

<p>Deep CGMs are trained to maximize the conditional marginal log-likelihood. Often the objective function is intractable, 
and we apply the SGVB framework to train the model. The empirical lower bound is written as:</p>

\[\tilde{\mathcal{L}}_{\text{CVAE}}(x, y; \theta, \phi) = -KL(q_{\phi}(z | x, y) || p_{\theta}(z | x)) + \frac{1}{L}\sum_{l=1}^{L}\log p_{\theta}(y | x, z^{(l)})\]

<p>where $\bf z^{(l)}$ is a Gaussian latent variable, and $L$ is the number of samples (or particles in Pyro nomenclature).
We call this model conditional variational auto-encoder (CVAE). The CVAE is composed of multiple MLPs, such as 
<strong>recognition network</strong> $q_{\phi}({\bf z} | \bf{x, y})$, <strong>(conditional) prior network</strong> $p_{\theta}(\bf{z} | \bf{x})$, 
and <strong>generation network</strong> $p_{\theta}(\bf{y} | \bf{x, z})$. In designing the network architecture, we build the 
network components of the CVAE <strong>on top of the baseline NN</strong>. Specifically, as shown in (d) above, not only the direct 
input $\bf x$, but also the initial guess $\hat{y}$ made by the NN are fed into the prior network.</p>

<p>Pyro makes it really easy to translate this architecture into code. The recognition network and the (conditional) 
prior network are encoders from the traditional VAE setting, while the generation network is the decoder:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Encoder</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">784</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc31</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_2</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc32</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_2</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="c1"># put x and y together in the same image for simplification
</span>        <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">xc</span><span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">xc</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
        <span class="c1"># then compute the hidden units
</span>        <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">xc</span><span class="p">))</span>
        <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">hidden</span><span class="p">))</span>
        <span class="c1"># then return a mean vector and a (positive) square root covariance
</span>        <span class="c1"># each of size batch_size x z_dim
</span>        <span class="n">z_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">fc31</span><span class="p">(</span><span class="n">hidden</span><span class="p">)</span>
        <span class="n">z_scale</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc32</span><span class="p">(</span><span class="n">hidden</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">z_loc</span><span class="p">,</span> <span class="n">z_scale</span>


<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_2</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">y</span>


<span class="k">class</span> <span class="nc">CVAE</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">,</span> <span class="n">pre_trained_baseline_net</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># The CVAE is composed of multiple MLPs, such as recognition network
</span>        <span class="c1"># qφ(z|x, y), (conditional) prior network pθ(z|x), and generation
</span>        <span class="c1"># network pθ(y|x, z). Also, CVAE is built on top of the NN: not only
</span>        <span class="c1"># the direct input x, but also the initial guess y_hat made by the NN
</span>        <span class="c1"># are fed into the prior network.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">baseline_net</span> <span class="o">=</span> <span class="n">pre_trained_baseline_net</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prior_net</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">generation_net</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">recognition_net</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_1</span><span class="p">,</span> <span class="n">hidden_2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># register this pytorch module and all of its sub-modules with pyro
</span>        <span class="n">pyro</span><span class="p">.</span><span class="n">module</span><span class="p">(</span><span class="s">"generation_net"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">xs</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">pyro</span><span class="p">.</span><span class="n">plate</span><span class="p">(</span><span class="s">"data"</span><span class="p">):</span>

            <span class="c1"># Prior network uses the baseline predictions as initial guess.
</span>            <span class="c1"># This is the generative process with recurrent connection
</span>            <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="c1"># this ensures the training process does not change the
</span>                <span class="c1"># baseline network
</span>                <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">baseline_net</span><span class="p">(</span><span class="n">xs</span><span class="p">).</span><span class="n">view</span><span class="p">(</span><span class="n">xs</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># sample the handwriting style from the prior distribution, which is
</span>            <span class="c1"># modulated by the input xs.
</span>            <span class="n">prior_loc</span><span class="p">,</span> <span class="n">prior_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">prior_net</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">)</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">pyro</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="s">'z'</span><span class="p">,</span> <span class="n">dist</span><span class="p">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">prior_loc</span><span class="p">,</span> <span class="n">prior_scale</span><span class="p">).</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># the output y is generated from the distribution pθ(y|x, z)
</span>            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generation_net</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># In training, we will only sample in the masked image
</span>                <span class="n">mask_loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[(</span><span class="n">xs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)].</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">mask_ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">xs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pyro</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="s">'y'</span><span class="p">,</span> <span class="n">dist</span><span class="p">.</span><span class="n">Bernoulli</span><span class="p">(</span><span class="n">mask_loc</span><span class="p">).</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">obs</span><span class="o">=</span><span class="n">mask_ys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In testing, no need to sample: the output is already a
</span>                <span class="c1"># probability in [0, 1] range, which better represent pixel
</span>                <span class="c1"># values considering grayscale. If we sample, we will force
</span>                <span class="c1"># each pixel to be  either 0 or 1, killing the grayscale
</span>                <span class="n">pyro</span><span class="p">.</span><span class="n">deterministic</span><span class="p">(</span><span class="s">'y'</span><span class="p">,</span> <span class="n">loc</span><span class="p">.</span><span class="n">detach</span><span class="p">())</span>

            <span class="c1"># return the loc so we can visualize it later
</span>            <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">guide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">pyro</span><span class="p">.</span><span class="n">plate</span><span class="p">(</span><span class="s">"data"</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ys</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># at inference time, ys is not provided. In that case,
</span>                <span class="c1"># the model uses the prior network
</span>                <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">baseline_net</span><span class="p">(</span><span class="n">xs</span><span class="p">).</span><span class="n">view</span><span class="p">(</span><span class="n">xs</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">prior_net</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># at training time, uses the variational distribution
</span>                <span class="c1"># q(z|x,y) = normal(loc(x,y),scale(x,y))
</span>                <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">recognition_net</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>

            <span class="n">pyro</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">dist</span><span class="p">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">).</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></code></pre></figure>

<h2 id="training">Training</h2>
<p>The training code can be found in the <a href="https://github.com/pyro-ppl/pyro/tree/dev/examples/cvae">Github repo</a>. 
Click play in the video below to watch how the CVAE learns throughout approximately 40 epochs.</p>

<video muted="" controls="" loop="" width="100%" class="video100">
    <source src="https://ucals-github.s3-sa-east-1.amazonaws.com/cvae_animation.mp4" type="video/mp4" />
    <source src="https://ucals-github.s3-sa-east-1.amazonaws.com/cvae_animation.webm" type="video/webm" />
    https://youtu.be/K7SEJMlzHD8
</video>

<p>As we can see, the model learned posterior distribution continuously improves as the training progresses: 
not only the loss goes down, but also we can see clearly how the predictions get better and better.</p>

<p>Additionally, here we can already observe the key advantage of CVAEs: the model learns to generate multiple predictions 
from a single input. In the first digit, the input is clearly a piece of a 7. The model learns it and keeps predicting 
clearer 7’s, but with different writing styles. In the second and third digits, the inputs are pieces of what could be 
either a 3 or a 5 (truth is 3), and what could be either a 4 or a 9 (truth is 4). During the first epochs, the CVAE 
predictions are blurred, and they get clearer as time passes, as expected.</p>

<p>However, different from the first digit, it’s hard to determine whether the truth is 3 and 4 for the second and third 
digits, respectively, by observing only one quarter of the digits as input. By the end of the training, the CVAE 
generates very clear and realistic predictions, but it doesn’t force either a 3 or a 5 for the second digit, and a 4 
or a 9 for the third digit. Sometimes it predicts one option, and sometimes it predicts another.</p>

<h2 id="evaluating-the-results">Evaluating the results</h2>
<p>For qualitative analysis, we visualize the generated output samples in the next figure. As we can see, the baseline 
NNs can only make a single deterministic prediction, and as a result the output looks blurry and doesn’t look 
realistic in many cases. In contrast, the samples generated by the CVAE models are more realistic and diverse in shape; 
sometimes they can even change their identity (digit labels), such as from 3 to 5 or from 4 to 9, and vice versa.</p>

<p><img src="https://i.ibb.co/Jvz9v71/cvae-q1.png" alt="image1" width="500" /></p>

<p>We also provide a quantitative evidence by estimating the marginal conditional log-likelihoods (CLLs) in next table 
(lower is better).</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>1 quadrant</th>
      <th>2 quadrants</th>
      <th>3 quadrants</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NN (baseline)</td>
      <td>100.4</td>
      <td>61.9</td>
      <td>25.4</td>
    </tr>
    <tr>
      <td>CVAE (Monte Carlo)</td>
      <td>71.8</td>
      <td>51.0</td>
      <td>24.2</td>
    </tr>
    <tr>
      <td>Performance gap</td>
      <td>28.6</td>
      <td>10.9</td>
      <td>1.2</td>
    </tr>
  </tbody>
</table>

<p>We achieved similar results to the ones achieved by the authors in the paper. We trained only for 50 epochs with early 
stopping patience of 3 epochs; to improve the results, we could leave the algorithm training for longer. Nevertheless, 
we can observe the same effect shown in the paper: <strong>the estimated CLLs of the CVAE significantly outperforms the 
baseline NN</strong>.</p>

<p>See the full code on <a href="https://github.com/pyro-ppl/pyro/blob/dev/examples/cvae">Github</a>.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="NIPS2015_5775">Sohn, K., Lee, H., &amp; Yan, X. (2015). Learning Structured Output Representation using Deep Conditional Generative Models. In C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, &amp; R. Garnett (Eds.), <i>Advances in Neural Information Processing Systems 28</i> (pp. 3483–3491). Curran Associates, Inc. http://papers.nips.cc/paper/5775-learning-structured-output-representation-using-deep-conditional-generative-models.pdf</span></li></ol>

  </div><a class="u-url" href="/paper/2020/09/18/conditional-variational-auto-encoder.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">carlos souza</li>
          <li><a class="u-email" href="mailto:souza@gatech.edu">souza@gatech.edu</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Interesting AI experiments</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
